# 实验四-优化Y86-64流水线处理器性能

## Y86-64指令集编码规范

首先是一些汇编的要求

* 参数的传法，第 1 个参数：`%rdi`，第 1 个参数：`%rsi`，第 3 个参数：`%rdx`，第4个参数：%rcx，第5个参数：%r8，第6个参数：%r9，返回值：`%rax`。
* 被调用者保存的寄存器：%rbx，%rbp，%r12，%r13，%r14，%r15。

**第一段：代码段（Code）**
 Y86 程序必须从 `.pos 0` 开始编写代码段，这是因为 Y86 CPU 启动时程序计数器 PC 固定为 0，第一条指令一定从内存地址 0 取指执行。`.pos 0` 并不是 CPU 指令，而是汇编器伪指令，用来告诉汇编器把接下来的机器码放在内存地址 0，从而保证 PC 能正确取到第一条指令。所有会被 CPU 执行的内容（主程序、函数代码）都属于代码段。

------

**第二段：数据段（Data）**
 数据段用于存放程序运行过程中需要访问的静态数据，例如链表节点等，通常通过 `.quad` 指令定义。`.quad` 表示在当前位置放置一个 64 位数据，而标签（如 `ele1:`）只是该地址的名字，本身不占内存。数据段应当放在代码段之后，并通过 `.align 8` 进行 8 字节对齐，以保证数据访问规范且不被 CPU 当作指令执行。

------

**第三段：栈段（Stack）**
 栈段是程序运行时使用的内存区域，用于保存函数返回地址和局部数据，由寄存器 `%rsp` 管理，且栈向低地址方向增长。通常通过 `.pos 0x200` 将栈起始地址放在较高的内存位置，再用标签 `stack:` 标记该地址。选择 0x200 是一种安全、保守的做法，它远离代码段和数据段，同时小于 Y86 地址空间上限（0xFFF），并满足 8 字节对齐要求。

------

**第四段：书写顺序与规则总结**
 在 Y86 实验中，推荐的书写顺序为：代码段 → 数据段 → 栈段。该顺序并非语法强制，而是为了保证程序入口明确、数据不被误执行、栈不覆盖代码和数据。`.pos 0` 必须保留作为程序入口，数据段只用于存放数据而不执行，栈段必须位于代码和数据之上并预留向下增长空间。而且最后的一行必须有回撤。

## Part A

### sum.ys-对链表元素进行迭代求和

这里就是简单地练习编写Y86代码，下面给出代码sum.ys

```

#------------------------------------------------
# sum.ys
# Name:徐文博
# 学号:1320240207
# 链表元素求和
#------------------------------------------------

    .pos 0
    irmovq stack, %rsp     # 初始化栈指针
    irmovq ele1, %rdi      # 传入第一个参数，链表头第一个元素地址
    call sum_list          # 调用sum_list函数
    halt                   # 程序结束

#------------------------------------------------
# long sum_list(list_ptr ls)
# %rdi = ls
# 返回指针在%rax中
#------------------------------------------------
sum_list:
    xorq %rax, %rax        #作为返回结果

Loop:
    andq %rdi, %rdi      # 判断参数ls是否为NULL
    je Done               # 如果是NULL，跳转到Done
    mrmovq 0(%rdi), %r10  # 取出当前节点的8字节值并放入r10
    addq %r10, %rax       # 将当前节点的值加到返回值中
    mrmovq 8(%rdi), %rdi  # 取出下一个节点的地址放入rdi中
    jmp Loop              # 继续循环
Done:
    ret


#------------------------------------------------
# 链表元素示例
#------------------------------------------------
    .align 8
ele1:
    .quad 0x00a     # long的大小为8字节（.quad），0x00a是当前节点的值
    .quad ele2       # 下一个节点的地址
ele2:
    .quad 0x0b0
    .quad ele3
ele3:
    .quad 0xc00
    .quad 0


#------------------------------------------------
# 栈空间
#------------------------------------------------
    .pos 0x200
stack:


```

下面给出sum.yo

```
                            | 
                            | #------------------------------------------------
                            | # sum.ys
                            | # Name:徐文博
                            | # 学号:1320240207
                            | # 链表元素求和
                            | #------------------------------------------------
                            | 
0x000:                      |     .pos 0
0x000: 30f40002000000000000 |     irmovq stack, %rsp     # 初始化栈指针
0x00a: 30f75000000000000000 |     irmovq ele1, %rdi      # 传入第一个参数，链表头第一个元素地址
0x014: 801e00000000000000   |     call sum_list          # 调用sum_list函数
0x01d: 00                   |     halt                   # 程序结束
                            | 
                            | #------------------------------------------------
                            | # long sum_list(list_ptr ls)
                            | # %rdi = ls
                            | # 返回指针在%rax中
                            | #------------------------------------------------
0x01e:                      | sum_list:
0x01e: 6300                 |     xorq %rax, %rax        #作为返回结果
                            | 
0x020:                      | Loop:
0x020: 6277                 |     andq %rdi, %rdi      # 判断参数ls是否为NULL
0x022: 734a00000000000000   |     je Done               # 如果是NULL，跳转到Done
0x02b: 50a70000000000000000 |     mrmovq 0(%rdi), %r10  # 取出当前节点的8字节值并放入r10
0x035: 60a0                 |     addq %r10, %rax       # 将当前节点的值加到返回值中
0x037: 50770800000000000000 |     mrmovq 8(%rdi), %rdi  # 取出下一个节点的地址放入rdi中
0x041: 702000000000000000   |     jmp Loop              # 继续循环
0x04a:                      | Done:
0x04a: 90                   |     ret
                            | 
                            | 
                            | #------------------------------------------------
                            | # 链表元素示例
                            | #------------------------------------------------
0x050:                      |     .align 8
0x050:                      | ele1:
0x050: 0a00000000000000     |     .quad 0x00a     # long的大小为8字节（.quad），0x00a是当前节点的值
0x058: 6000000000000000     |     .quad ele2       # 下一个节点的地址
0x060:                      | ele2:
0x060: b000000000000000     |     .quad 0x0b0
0x068: 7000000000000000     |     .quad ele3
0x070:                      | ele3:
0x070: 000c000000000000     |     .quad 0xc00
0x078: 0000000000000000     |     .quad 0
                            | 
                            | 
                            | #------------------------------------------------
                            | # 栈空间
                            | #------------------------------------------------
0x200:                      |     .pos 0x200
0x200:                      | stack:
                            | 

```

下面附上运行截图

![image-20251217184458419](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251217184458465.png)

### rsum.ys-对链表元素进行递归求和

这里比上一道需要注意的是，我们在递归时，第一个参数一定是存放在%rdi的，所以在递归之前`long val = ls->val;`，只能用%r10存放节点数值，然后再压入栈中（因为这是调用者保存，后面我们递归调用rsum_list会覆盖寄存器%r10），而这里也需要两个ret，一个是在Empty链表时ret，一个是正常递归完ret避免顺序执行到Empty:。

下面附上rsum.ys代码

```
# rsum.ys
# Name:徐文博
# 学号:1320240207


    .pos 0
    irmovq stack, %rsp    # 初始化栈指针
    irmovq ele1, %rdi     # 传入第一个参数，链表头第一个元素地址
    call rsum_list        # 调用rsum_list函数
    halt                  # 程序结束

#------------------------------------------------
# long rsum_list(list_ptr ls)
# %rdi = ls
# 返回指保存在%rax中
#------------------------------------------------
rsum_list:
    # if (!ls) return 0;
    andq %rdi,%rdi      # 判断参数ls是否为NULL
    je Empty             # 如果是NULL，跳转到Done，即空链表
    
    # long val = ls->value;
    mrmovq 0(%rdi), %r10  # 取出当前节点的8字节值并放入r10
                        #这里不用%rdi,是因为下面还要用到%rdi取下一个节点地址
                        #并call时要用到%rdi传参
    pushq %r10         # 将当前节点的值压栈保存,调用者保存
                       # 以便下面递归调用后再取出使用

    # long rest = rsum_list(ls->next);
    mrmovq 8(%rdi),%rdi # 取出下一个节点的地址放入rdi中
    call rsum_list      # 递归调用rsum_list

    # return val + rest;
    popq %r10
    addq %r10,%rax
    ret

    
Empty:
    xorq %rax,%rax        # 作为返回结果初始化为0
    ret


# 链表元素示例
    .align 8
ele1:
    .quad 0x00a     # long的大小为8字节（.quad），0x00a是当前节点的值
    .quad ele2       # 下一个节点的地址
ele2:
    .quad 0x0b0
    .quad ele3
ele3:
    .quad 0xc00
    .quad 0


# 栈区
    .pos 0x200
stack:


```

下面附上rsum.yo内容

```
                            | # rsum.ys
                            | # Name:徐文博
                            | # 学号:1320240207
                            | 
                            | 
0x000:                      |     .pos 0
0x000: 30f40002000000000000 |     irmovq stack, %rsp    # 初始化栈指针
0x00a: 30f75000000000000000 |     irmovq ele1, %rdi     # 传入第一个参数，链表头第一个元素地址
0x014: 801e00000000000000   |     call rsum_list        # 调用rsum_list函数
0x01d: 00                   |     halt                  # 程序结束
                            | 
                            | #------------------------------------------------
                            | # long rsum_list(list_ptr ls)
                            | # %rdi = ls
                            | # 返回指保存在%rax中
                            | #------------------------------------------------
0x01e:                      | rsum_list:
                            |     # if (!ls) return 0;
0x01e: 6277                 |     andq %rdi,%rdi      # 判断参数ls是否为NULL
0x020: 734d00000000000000   |     je Empty             # 如果是NULL，跳转到Done，即空链表
                            |     
                            |     # long val = ls->value;
0x029: 50a70000000000000000 |     mrmovq 0(%rdi), %r10  # 取出当前节点的8字节值并放入r10
                            |                         #这里不用%rdi,是因为下面还要用到%rdi取下一个节点地址
                            |                         #并call时要用到%rdi传参
0x033: a0af                 |     pushq %r10         # 将当前节点的值压栈保存,调用者保存
                            |                        # 以便下面递归调用后再取出使用
                            | 
                            |     # long rest = rsum_list(ls->next);
0x035: 50770800000000000000 |     mrmovq 8(%rdi),%rdi # 取出下一个节点的地址放入rdi中
0x03f: 801e00000000000000   |     call rsum_list      # 递归调用rsum_list
                            | 
                            |     # return val + rest;
0x048: b0af                 |     popq %r10
0x04a: 60a0                 |     addq %r10,%rax
0x04c: 90                   |     ret
                            | 
                            |     
0x04d:                      | Empty:
0x04d: 6300                 |     xorq %rax,%rax        # 作为返回结果初始化为0
0x04f: 90                   |     ret
                            | 
                            | 
                            | # 链表元素示例
0x050:                      |     .align 8
0x050:                      | ele1:
0x050: 0a00000000000000     |     .quad 0x00a     # long的大小为8字节（.quad），0x00a是当前节点的值
0x058: 6000000000000000     |     .quad ele2       # 下一个节点的地址
0x060:                      | ele2:
0x060: b000000000000000     |     .quad 0x0b0
0x068: 7000000000000000     |     .quad ele3
0x070:                      | ele3:
0x070: 000c000000000000     |     .quad 0xc00
0x078: 0000000000000000     |     .quad 0
                            | 
                            | 
                            | # 栈区
0x200:                      |     .pos 0x200
0x200:                      | stack:
                            | 

```



下面附上运行截图

![image-20251217184425160](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251217184425267.png)

### copy.ys-复制元素

下面附上代码以及运行效果

```
# copy.ys
# Name:徐文博
# 学号:1320240207
# 链表元素复制


    .pos 0
    irmovq stack, %rsp     # 初始化栈指针
    irmovq src, %rdi   # 传入第一个参数，Source链表头第一个元素地址
    irmovq dest, %rsi  # 传入第二个参数，Dest链表头第一个元素地址
    irmovq $3, %rdx     # 传入第三个参数，链表元素个数
    call copy_list        # 调用copy_list函数
    halt                  # 程序结束

#------------------------------------------------
# void copy_list(list_ptr src, list_ptr dest, long n)
# %rdi = src
# %rsi = dest
# %rdx = n
#------------------------------------------------
copy_list:
    xorq %rax, %rax     # long result = 0;

Loop:
    andq %rdx, %rdx     # len <= 0?
    je Done            # if (len <= 0) break;

    mrmovq (%rdi), %r10 # long val = *src;
    rmmovq %r10, (%rsi) # *dest = val;
    xorq %r10, %rax     # result ^= val;

    irmovq $8, %r11 #因为long类型占8字节，
                    #因此src++和dest++都要加8
                    #Y86只支持寄存器相加
    addq %r11, %rdi   # src++;
    addq %r11, %rsi   # dest++;

    irmovq $1, %r11   # len--;
    subq %r11, %rdx

    jmp Loop                    

Done:
    ret


# Source链表和Dest链表的定义
    .align 8
src:
    .quad 0x00a
    .quad 0x0b0
    .quad 0xc00
dest:
    .quad 0x111
    .quad 0x222
    .quad 0x333


    .pos 0x200
stack:

```

下面是copy.yo

```
                            | # copy.ys
                            | # Name:徐文博
                            | # 学号:1320240207
                            | # 链表元素复制
                            | 
                            | 
0x000:                      |     .pos 0
0x000: 30f40002000000000000 |     irmovq stack, %rsp     # 初始化栈指针
0x00a: 30f78000000000000000 |     irmovq src, %rdi   # 传入第一个参数，Source链表头第一个元素地址
0x014: 30f69800000000000000 |     irmovq dest, %rsi  # 传入第二个参数，Dest链表头第一个元素地址
0x01e: 30f20300000000000000 |     irmovq $3, %rdx     # 传入第三个参数，链表元素个数
0x028: 803200000000000000   |     call copy_list        # 调用copy_list函数
0x031: 00                   |     halt                  # 程序结束
                            | 
                            | #------------------------------------------------
                            | # void copy_list(list_ptr src, list_ptr dest, long n)
                            | # %rdi = src
                            | # %rsi = dest
                            | # %rdx = n
                            | #------------------------------------------------
0x032:                      | copy_list:
0x032: 6300                 |     xorq %rax, %rax     # long result = 0;
                            | 
0x034:                      | Loop:
0x034: 6222                 |     andq %rdx, %rdx     # len <= 0?
0x036: 737800000000000000   |     je Done            # if (len <= 0) break;
                            | 
0x03f: 50a70000000000000000 |     mrmovq (%rdi), %r10 # long val = *src;
0x049: 40a60000000000000000 |     rmmovq %r10, (%rsi) # *dest = val;
0x053: 63a0                 |     xorq %r10, %rax     # result ^= val;
                            | 
0x055: 30fb0800000000000000 |     irmovq $8, %r11 #因为long类型占8字节，
                            |                     #因此src++和dest++都要加8
                            |                     #Y86只支持寄存器相加
0x05f: 60b7                 |     addq %r11, %rdi   # src++;
0x061: 60b6                 |     addq %r11, %rsi   # dest++;
                            | 
0x063: 30fb0100000000000000 |     irmovq $1, %r11   # len--;
0x06d: 61b2                 |     subq %r11, %rdx
                            | 
0x06f: 703400000000000000   |     jmp Loop                    
                            | 
0x078:                      | Done:
0x078: 90                   |     ret
                            | 
                            | 
                            | # Source链表和Dest链表的定义
0x080:                      |     .align 8
0x080:                      | src:
0x080: 0a00000000000000     |     .quad 0x00a
0x088: b000000000000000     |     .quad 0x0b0
0x090: 000c000000000000     |     .quad 0xc00
0x098:                      | dest:
0x098: 1101000000000000     |     .quad 0x111
0x0a0: 2202000000000000     |     .quad 0x222
0x0a8: 3303000000000000     |     .quad 0x333
                            | 
                            | 
0x200:                      |     .pos 0x200
0x200:                      | stack:

```

下面则是截图

![image-20251217184335747](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251217184341155.png)

## PartB

下面给出具体修改

```
bool instr_valid = icode in 
	{ INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,
	       IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ, IIADDQ };

bool need_regids =
	icode in { IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, 
		     IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ };

bool need_valC =
	icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL, IIADDQ };

word srcB = [
	icode in { IOPQ, IRMMOVQ, IMRMOVQ, IIADDQ  } : rB;
	icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;
	1 : RNONE;  # Don't need register
];


word dstE = [
	icode in { IRRMOVQ } && Cnd : rB;
	icode in { IIRMOVQ, IOPQ, IIADDQ } : rB;
	icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;
	1 : RNONE;  # Don't write any register
];

word aluA = [
	icode in { IRRMOVQ, IOPQ } : valA;
	icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ } : valC;
	icode in { ICALL, IPUSHQ } : -8;
	icode in { IRET, IPOPQ } : 8;
	# Other instructions don't need ALU
];

word aluB = [
	icode in { IRMMOVQ, IMRMOVQ, IOPQ, ICALL, 
		      IPUSHQ, IRET, IPOPQ, IIADDQ } : valB;
	icode in { IRRMOVQ, IIRMOVQ } : 0;
	# Other instructions don't need ALU
];
```

下面附上ISA测试截图

![image-20251217171540509](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251217171540595.png)

回归测试原有ISA截图

![image-20251217183236767](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251217183236818.png)

回归测试iaddq截图

![](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251217183333427.png)

## PartC

### 简述

讲真的，一下子看完archlab-cn.pdf的实验说明，没看懂，只知道有`ncopy.ys`，`pipe-full.hcl` ，`sdriver.yo和ldriver.yo`，`correctness.pl和benchmark.pl`，下面理一下思路。注意：下面的命令一切都是在sim/pipe/目录下执行。

1. `ncopy.ys`-汇编程序

   * 作用：这是我要实现的**Y86-64汇编程序**，其核心功能是：
     * 将一个数组`src`复制到另一个数组`dst`
     * 计算并返回`src`中大于零的元素个数，最终这个结果会存储在`%rax`寄存器中。
   * 目的：我需要优化它的**执行周期（CPE）**，确保它在不同输入规模下的执行效率和正确性。
2. `pipe-full.hcl`-流水线处理器的控制逻辑

   * 作用：这是**流水线CPU的硬件控制逻辑**，我需要在这里定义处理器如何执行`ncopy.ys`中的指令。它决定了：

     * **流水线各阶段**（取值、译码、执行、访存、写回）如何工作。
     * 如何优化流水线中的**数据转发、分支预测、冒险控制**等。
   * 和`ncopy.ys`的关系：

     * `ncopy.ys`运行时会依赖`pipe-full.hcl`里的控制逻辑，流水线的控制逻辑会影响`ncopy.ys`的执行效率。
3. `sdriver.yo`和`ldriver.yo`-测试程序
   * 作用：
     * `sdriver.yo`：测试`ncopy.ys`在一个小数组（4个元素）上的正确性。如果`ncopy.ys`正确执行，它会在`%rax`中返回2。
     * `ldriver.yo`：测试`ncopy.ys`在一个大数组（63个元素）上的正确性。如果`ncopy.ys`正确执行，那么它会在`%rax`中返回31。
4. `correctness.pl`-一个更严格的正确测试
   * 作用：这是一个**自动化测试工具**，用来确保`ncopy.ys`在各种不同大小的数组上的正确性。
   * 测试内容：
     * 它会自动生成多种不同大小的数组，并测试`ncopy.ys`函数是否正确复制数据并计算正整数个数。
5. `benchmark.pl`-性能测试工具
   * 作用：顾名思义，用来测试`ncopy.ys`的性能
   * 测试内容：
     * 它会运行`ncopy.ys`函数，计算并复制每一个元素需要多少周期（CPE）。
     * 目标是CPE<9。

下面我打算在修改之前，我先跑一遍，下面给出命令

1. `make drivers`：是用来生成测试驱动程序的，执行后会自动生成并汇编两个 `.yo` 文件（`sdriver.yo` 和 `ldriver.yo`），分别用于小数组和大数组的测试。

2. `make psim VERSION=full`：这个命令会重新编译**流水线模拟器（PSIM）**，编译时会由 `pipe-full.hcl` 生成对应的 `pipe-full.c`（HCL→C），再与 `psim.c`、`isa.c` 等一起编译生成可执行文件 `psim`。

   > 注意：`make VERSION=full`= `make drivers`+`make psim VERSION=full`

3. `./psim -g sdriver.yo`：`sdriver.yo`是一个测试小数组（4个元素）的程序，它会调用我们编写的`ncopy.ys`函数执行数组复制，并返回正整数的数量（即`%rax`中的值）。

   `sdriver.yo`/`ldriver.yo` 是驱动程序；用 `psim` 运行时体现流水线执行，用 `yis` 运行时体现顺序执行。

   > 我这里第一次运行时，出了一个问题，可能是没有执行`make clean`清理之前的编译缓存。因此我执行了`make clean`，然后执行`make VERSION=full`，再运行`./psim -g sdriver.yo`则成功出现了GUI页面，也运行成功。

4. `./psim -g ldriver.yo`：是用来 **测试大数组（63 个元素）** 的，它会启动 **PSIM 模拟器**（流水线） 并加载之前生成的 **`ldriver.yo`** 驱动程序文件，进入 **GUI 模式** 来运行模拟。

   下面附上截图

   ![image-20251217223243077](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251217223248193.png)

5. `../misc/yis sdriver.yo`：该指令会启动YIS模拟器（顺序执行），并加载`sdriver.yo`驱动程序。同样通过检查`%rax`的最终值是否正确。这回和之前的`./psim`不同，这个是使用YIS模拟器，`./psim -g sdriver.yo`是利用我们自己的pipe模拟器，YIS模拟器是来判断`ncopy.ys`汇编的正确性。

   下面附上截图

   ![](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251217224830106.png)

6. `correctness.pl`：是一个脚本，它会生成一系列的测试程序，每个程序的块从0到65,再加上一些更大的块长度（块长度就是我们需要复制的数组的长度，例如4个元素，63ge元素）。这个脚本提供了比`sdriver.yo`和`ldriver.yo`更严格的测试，同时**结果会随机变化**（每次测试，数组中的个数可能不同），这会验证程序的准确定和稳定性。

   具体操作步骤

   * 运行`correctness.pl`：它会生成多个测试程序，自动执行并验证 `ncopy.ys` 是否正确。

   * 如果在运行`correctness.pl`后发现某个特定长度的测试失败，可以用`gen-driver.pl`脚本来生成特定长度的**自定义驱动程序**。

   * 假设某个长度为 **K** 的测试失败，你可以通过以下命令生成自定义的驱动程序：

     ```
     ./gen-driver.pl -f ncopy.ys -n K -rc > driver.ys //生成自定义的驱动程序
     make driver.yo //将生成的driver.ys编译为.yo文件
     ../misc/yis driver.yo //使用YIS模拟器来运行这个编译后的驱动程序
     ```

   * 检查`%rax`寄存器的值：

     在测试过程中，YIS 模拟器会根据测试结果将值存储在 `%rax` 寄存器中。我们需要检查 `%rax` 的值来判断测试是否成功：

     **`0xaaaa`**：所有测试通过，程序没有错误。

     **`0xbbbb`**：计数不正确，说明 `ncopy.ys` 函数返回的正整数个数有误。

     **`0xcccc`**：`ncopy` 函数的长度超过了 1000 字节，可能是因为你的程序写得过长，需要优化。

     **`0xdddd`**：某些源数据没有被正确复制到目标数组。

     **`0xeeee`**：目标区域前后有数据被损坏（超出了目标数组的边界）。

   下面附上截图

   ![image-20251217230212925](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251217230213008.png)

7. `(cd ../y86-code; make testpsim)`： 这是基准测试，是利用sim/y86-code里面的Y86-64寄存程序进行测试，其实就是测试：我们改了`pipe-full.hcl`以后，有没有把CPU的其他行为搞坏。这个和第8点的回归测试目的一样（只不过回归测试更全面）。下面附上截图

   ![image-20251218091537278](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251218091537393.png)

8. `(cd ../ptest; make SIM=../pipe/psim TFLAGS=-i)`：这是进行回归测试：也是测试，我们的`pipe-full.hcl`逻辑是否正确。下面附上截图

   ![image-20251218092052612](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251218092052697.png)

   这里有错误很正常，因为`TFLAGS=-i`会另外测试我们在pipe-full.hcl里面添加的iaddq，但现在我只是在跑通，所以很正常，如果我们执行`(cd ../ptest; make SIM=../pipe/psim)`，那么将不会有问题。

9. `./correctness.pl -p`：这条指令和`./correctness`很像，但不同在于，`./correctness.pl`测的是 `ncopy.ys` 在**顺序执行**下是否正确，`correctness.pl -p` 测的是`ncopy` 在「流水线执行」下是否正确。下面附上截图

   ![](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251218092926758.png)

10. `benchmark.pl`：`benchmark.pl` 会用流水线 CPU（psim） 在大规模 ncopy 上测：平均每复制一个元素要多少个时钟周期（CPE）。下面附上截图

    ![](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251218093246840.png)

    正常，我还没修改自然是0分。

### 简述小结

因此我们知道了，目前看来，`ncopy.ys`是正确的，只是效率不高

1. 目的：

   * 修改`ncopy.ys`，目的是让其效率更高
   * 修改`pipe-full.hcl`，目的是加入`IIADDQ`同时效率更高。

2. 各个测试对比：

   * `sdriver.yo`和`ldrvier.yo`是来测试`ncopy.yo`的正确性
   * `correctness.pl`是使用YIS（顺序ISA模拟器）在多种不同规模下测试`ncopy.ys`，进行正确性测试。
   * `correctness.pl -p`：与`correctness.pl`不同在于，流水线执行正确性测试
   * `testpsim`：基准程序测试，使用 `sim/y86-code` 中提供的标准 Y86-64 程序；验证修改 `pipe-full.hcl` 后，处理器是否仍能正确执行“非 ncopy”程序；用于检测是否引入了影响全局行为的错误。
   * `ptest`：回归测试，对流水线处理器进行更全面、系统性的指令级回归测试；覆盖算术指令、跳转指令、调用与返回等多种场景；若未实现 `iaddq`，需避免使用 `TFLAGS=-i` 选项。
   * `benchmark.pl`：性能测试，在确认所有正确性测试通过后运行；使用流水线处理器 `psim` 测量 `ncopy.ys` 的执行性能；以 CPE（Cycles Per Element）作为评价指标，反映程序在流水线下的平均执行效率。

   > 注意：本实验中，同一个`ncopy.ys`程序，会在两种不同的处理器模型上被反复执行和验证：
   >
   > * `../misc/yis`：顺序处理器（YIS）
   > * `./psim`：流水线执行（PSIM）测试

### 阅读 `ncopy.ys` 和 `pipe-full.hcl`





















