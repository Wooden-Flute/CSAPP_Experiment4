# 实验四-优化Y86-64流水线处理器性能

## Y86-64指令集编码规范

首先是一些汇编的要求

* 参数的传法，第 1 个参数：`%rdi`，第 1 个参数：`%rsi`，第 3 个参数：`%rdx`，第4个参数：%rcx，第5个参数：%r8，第6个参数：%r9，返回值：`%rax`。
* 被调用者保存的寄存器：%rbx，%rbp，%r12，%r13，%r14，%r15。

**第一段：代码段（Code）**
 Y86 程序必须从 `.pos 0` 开始编写代码段，这是因为 Y86 CPU 启动时程序计数器 PC 固定为 0，第一条指令一定从内存地址 0 取指执行。`.pos 0` 并不是 CPU 指令，而是汇编器伪指令，用来告诉汇编器把接下来的机器码放在内存地址 0，从而保证 PC 能正确取到第一条指令。所有会被 CPU 执行的内容（主程序、函数代码）都属于代码段。

------

**第二段：数据段（Data）**
 数据段用于存放程序运行过程中需要访问的静态数据，例如链表节点等，通常通过 `.quad` 指令定义。`.quad` 表示在当前位置放置一个 64 位数据，而标签（如 `ele1:`）只是该地址的名字，本身不占内存。数据段应当放在代码段之后，并通过 `.align 8` 进行 8 字节对齐，以保证数据访问规范且不被 CPU 当作指令执行。

------

**第三段：栈段（Stack）**
 栈段是程序运行时使用的内存区域，用于保存函数返回地址和局部数据，由寄存器 `%rsp` 管理，且栈向低地址方向增长。通常通过 `.pos 0x200` 将栈起始地址放在较高的内存位置，再用标签 `stack:` 标记该地址。选择 0x200 是一种安全、保守的做法，它远离代码段和数据段，同时小于 Y86 地址空间上限（0xFFF），并满足 8 字节对齐要求。

------

**第四段：书写顺序与规则总结**
 在 Y86 实验中，推荐的书写顺序为：代码段 → 数据段 → 栈段。该顺序并非语法强制，而是为了保证程序入口明确、数据不被误执行、栈不覆盖代码和数据。`.pos 0` 必须保留作为程序入口，数据段只用于存放数据而不执行，栈段必须位于代码和数据之上并预留向下增长空间。而且最后的一行必须有回撤。

## Part A

### sum.ys-对链表元素进行迭代求和

这里就是简单地练习编写Y86代码，下面给出代码sum.ys

```

#------------------------------------------------
# sum.ys
# Name:徐文博
# 学号:1320240207
# 链表元素求和
#------------------------------------------------

    .pos 0
    irmovq stack, %rsp     # 初始化栈指针
    irmovq ele1, %rdi      # 传入第一个参数，链表头第一个元素地址
    call sum_list          # 调用sum_list函数
    halt                   # 程序结束

#------------------------------------------------
# long sum_list(list_ptr ls)
# %rdi = ls
# 返回指针在%rax中
#------------------------------------------------
sum_list:
    xorq %rax, %rax        #作为返回结果

Loop:
    andq %rdi, %rdi      # 判断参数ls是否为NULL
    je Done               # 如果是NULL，跳转到Done
    mrmovq 0(%rdi), %r10  # 取出当前节点的8字节值并放入r10
    addq %r10, %rax       # 将当前节点的值加到返回值中
    mrmovq 8(%rdi), %rdi  # 取出下一个节点的地址放入rdi中
    jmp Loop              # 继续循环
Done:
    ret


#------------------------------------------------
# 链表元素示例
#------------------------------------------------
    .align 8
ele1:
    .quad 0x00a     # long的大小为8字节（.quad），0x00a是当前节点的值
    .quad ele2       # 下一个节点的地址
ele2:
    .quad 0x0b0
    .quad ele3
ele3:
    .quad 0xc00
    .quad 0


#------------------------------------------------
# 栈空间
#------------------------------------------------
    .pos 0x200
stack:


```

下面给出sum.yo

```
                            | 
                            | #------------------------------------------------
                            | # sum.ys
                            | # Name:徐文博
                            | # 学号:1320240207
                            | # 链表元素求和
                            | #------------------------------------------------
                            | 
0x000:                      |     .pos 0
0x000: 30f40002000000000000 |     irmovq stack, %rsp     # 初始化栈指针
0x00a: 30f75000000000000000 |     irmovq ele1, %rdi      # 传入第一个参数，链表头第一个元素地址
0x014: 801e00000000000000   |     call sum_list          # 调用sum_list函数
0x01d: 00                   |     halt                   # 程序结束
                            | 
                            | #------------------------------------------------
                            | # long sum_list(list_ptr ls)
                            | # %rdi = ls
                            | # 返回指针在%rax中
                            | #------------------------------------------------
0x01e:                      | sum_list:
0x01e: 6300                 |     xorq %rax, %rax        #作为返回结果
                            | 
0x020:                      | Loop:
0x020: 6277                 |     andq %rdi, %rdi      # 判断参数ls是否为NULL
0x022: 734a00000000000000   |     je Done               # 如果是NULL，跳转到Done
0x02b: 50a70000000000000000 |     mrmovq 0(%rdi), %r10  # 取出当前节点的8字节值并放入r10
0x035: 60a0                 |     addq %r10, %rax       # 将当前节点的值加到返回值中
0x037: 50770800000000000000 |     mrmovq 8(%rdi), %rdi  # 取出下一个节点的地址放入rdi中
0x041: 702000000000000000   |     jmp Loop              # 继续循环
0x04a:                      | Done:
0x04a: 90                   |     ret
                            | 
                            | 
                            | #------------------------------------------------
                            | # 链表元素示例
                            | #------------------------------------------------
0x050:                      |     .align 8
0x050:                      | ele1:
0x050: 0a00000000000000     |     .quad 0x00a     # long的大小为8字节（.quad），0x00a是当前节点的值
0x058: 6000000000000000     |     .quad ele2       # 下一个节点的地址
0x060:                      | ele2:
0x060: b000000000000000     |     .quad 0x0b0
0x068: 7000000000000000     |     .quad ele3
0x070:                      | ele3:
0x070: 000c000000000000     |     .quad 0xc00
0x078: 0000000000000000     |     .quad 0
                            | 
                            | 
                            | #------------------------------------------------
                            | # 栈空间
                            | #------------------------------------------------
0x200:                      |     .pos 0x200
0x200:                      | stack:
                            | 

```

下面附上运行截图

![image-20251217184458419](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251217184458465.png)

### rsum.ys-对链表元素进行递归求和

这里比上一道需要注意的是，我们在递归时，第一个参数一定是存放在%rdi的，所以在递归之前`long val = ls->val;`，只能用%r10存放节点数值，然后再压入栈中（因为这是调用者保存，后面我们递归调用rsum_list会覆盖寄存器%r10），而这里也需要两个ret，一个是在Empty链表时ret，一个是正常递归完ret避免顺序执行到Empty:。

下面附上rsum.ys代码

```
# rsum.ys
# Name:徐文博
# 学号:1320240207


    .pos 0
    irmovq stack, %rsp    # 初始化栈指针
    irmovq ele1, %rdi     # 传入第一个参数，链表头第一个元素地址
    call rsum_list        # 调用rsum_list函数
    halt                  # 程序结束

#------------------------------------------------
# long rsum_list(list_ptr ls)
# %rdi = ls
# 返回指保存在%rax中
#------------------------------------------------
rsum_list:
    # if (!ls) return 0;
    andq %rdi,%rdi      # 判断参数ls是否为NULL
    je Empty             # 如果是NULL，跳转到Done，即空链表
    
    # long val = ls->value;
    mrmovq 0(%rdi), %r10  # 取出当前节点的8字节值并放入r10
                        #这里不用%rdi,是因为下面还要用到%rdi取下一个节点地址
                        #并call时要用到%rdi传参
    pushq %r10         # 将当前节点的值压栈保存,调用者保存
                       # 以便下面递归调用后再取出使用

    # long rest = rsum_list(ls->next);
    mrmovq 8(%rdi),%rdi # 取出下一个节点的地址放入rdi中
    call rsum_list      # 递归调用rsum_list

    # return val + rest;
    popq %r10
    addq %r10,%rax
    ret

    
Empty:
    xorq %rax,%rax        # 作为返回结果初始化为0
    ret


# 链表元素示例
    .align 8
ele1:
    .quad 0x00a     # long的大小为8字节（.quad），0x00a是当前节点的值
    .quad ele2       # 下一个节点的地址
ele2:
    .quad 0x0b0
    .quad ele3
ele3:
    .quad 0xc00
    .quad 0


# 栈区
    .pos 0x200
stack:


```

下面附上rsum.yo内容

```
                            | # rsum.ys
                            | # Name:徐文博
                            | # 学号:1320240207
                            | 
                            | 
0x000:                      |     .pos 0
0x000: 30f40002000000000000 |     irmovq stack, %rsp    # 初始化栈指针
0x00a: 30f75000000000000000 |     irmovq ele1, %rdi     # 传入第一个参数，链表头第一个元素地址
0x014: 801e00000000000000   |     call rsum_list        # 调用rsum_list函数
0x01d: 00                   |     halt                  # 程序结束
                            | 
                            | #------------------------------------------------
                            | # long rsum_list(list_ptr ls)
                            | # %rdi = ls
                            | # 返回指保存在%rax中
                            | #------------------------------------------------
0x01e:                      | rsum_list:
                            |     # if (!ls) return 0;
0x01e: 6277                 |     andq %rdi,%rdi      # 判断参数ls是否为NULL
0x020: 734d00000000000000   |     je Empty             # 如果是NULL，跳转到Done，即空链表
                            |     
                            |     # long val = ls->value;
0x029: 50a70000000000000000 |     mrmovq 0(%rdi), %r10  # 取出当前节点的8字节值并放入r10
                            |                         #这里不用%rdi,是因为下面还要用到%rdi取下一个节点地址
                            |                         #并call时要用到%rdi传参
0x033: a0af                 |     pushq %r10         # 将当前节点的值压栈保存,调用者保存
                            |                        # 以便下面递归调用后再取出使用
                            | 
                            |     # long rest = rsum_list(ls->next);
0x035: 50770800000000000000 |     mrmovq 8(%rdi),%rdi # 取出下一个节点的地址放入rdi中
0x03f: 801e00000000000000   |     call rsum_list      # 递归调用rsum_list
                            | 
                            |     # return val + rest;
0x048: b0af                 |     popq %r10
0x04a: 60a0                 |     addq %r10,%rax
0x04c: 90                   |     ret
                            | 
                            |     
0x04d:                      | Empty:
0x04d: 6300                 |     xorq %rax,%rax        # 作为返回结果初始化为0
0x04f: 90                   |     ret
                            | 
                            | 
                            | # 链表元素示例
0x050:                      |     .align 8
0x050:                      | ele1:
0x050: 0a00000000000000     |     .quad 0x00a     # long的大小为8字节（.quad），0x00a是当前节点的值
0x058: 6000000000000000     |     .quad ele2       # 下一个节点的地址
0x060:                      | ele2:
0x060: b000000000000000     |     .quad 0x0b0
0x068: 7000000000000000     |     .quad ele3
0x070:                      | ele3:
0x070: 000c000000000000     |     .quad 0xc00
0x078: 0000000000000000     |     .quad 0
                            | 
                            | 
                            | # 栈区
0x200:                      |     .pos 0x200
0x200:                      | stack:
                            | 

```



下面附上运行截图

![image-20251217184425160](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251217184425267.png)

### copy.ys-复制元素

下面附上代码以及运行效果

```
# copy.ys
# Name:徐文博
# 学号:1320240207
# 链表元素复制


    .pos 0
    irmovq stack, %rsp     # 初始化栈指针
    irmovq src, %rdi   # 传入第一个参数，Source链表头第一个元素地址
    irmovq dest, %rsi  # 传入第二个参数，Dest链表头第一个元素地址
    irmovq $3, %rdx     # 传入第三个参数，链表元素个数
    call copy_list        # 调用copy_list函数
    halt                  # 程序结束

#------------------------------------------------
# void copy_list(list_ptr src, list_ptr dest, long n)
# %rdi = src
# %rsi = dest
# %rdx = n
#------------------------------------------------
copy_list:
    xorq %rax, %rax     # long result = 0;

Loop:
    andq %rdx, %rdx     # len <= 0?
    je Done            # if (len <= 0) break;

    mrmovq (%rdi), %r10 # long val = *src;
    rmmovq %r10, (%rsi) # *dest = val;
    xorq %r10, %rax     # result ^= val;

    irmovq $8, %r11 #因为long类型占8字节，
                    #因此src++和dest++都要加8
                    #Y86只支持寄存器相加
    addq %r11, %rdi   # src++;
    addq %r11, %rsi   # dest++;

    irmovq $1, %r11   # len--;
    subq %r11, %rdx

    jmp Loop                    

Done:
    ret


# Source链表和Dest链表的定义
    .align 8
src:
    .quad 0x00a
    .quad 0x0b0
    .quad 0xc00
dest:
    .quad 0x111
    .quad 0x222
    .quad 0x333


    .pos 0x200
stack:

```

下面是copy.yo

```
                            | # copy.ys
                            | # Name:徐文博
                            | # 学号:1320240207
                            | # 链表元素复制
                            | 
                            | 
0x000:                      |     .pos 0
0x000: 30f40002000000000000 |     irmovq stack, %rsp     # 初始化栈指针
0x00a: 30f78000000000000000 |     irmovq src, %rdi   # 传入第一个参数，Source链表头第一个元素地址
0x014: 30f69800000000000000 |     irmovq dest, %rsi  # 传入第二个参数，Dest链表头第一个元素地址
0x01e: 30f20300000000000000 |     irmovq $3, %rdx     # 传入第三个参数，链表元素个数
0x028: 803200000000000000   |     call copy_list        # 调用copy_list函数
0x031: 00                   |     halt                  # 程序结束
                            | 
                            | #------------------------------------------------
                            | # void copy_list(list_ptr src, list_ptr dest, long n)
                            | # %rdi = src
                            | # %rsi = dest
                            | # %rdx = n
                            | #------------------------------------------------
0x032:                      | copy_list:
0x032: 6300                 |     xorq %rax, %rax     # long result = 0;
                            | 
0x034:                      | Loop:
0x034: 6222                 |     andq %rdx, %rdx     # len <= 0?
0x036: 737800000000000000   |     je Done            # if (len <= 0) break;
                            | 
0x03f: 50a70000000000000000 |     mrmovq (%rdi), %r10 # long val = *src;
0x049: 40a60000000000000000 |     rmmovq %r10, (%rsi) # *dest = val;
0x053: 63a0                 |     xorq %r10, %rax     # result ^= val;
                            | 
0x055: 30fb0800000000000000 |     irmovq $8, %r11 #因为long类型占8字节，
                            |                     #因此src++和dest++都要加8
                            |                     #Y86只支持寄存器相加
0x05f: 60b7                 |     addq %r11, %rdi   # src++;
0x061: 60b6                 |     addq %r11, %rsi   # dest++;
                            | 
0x063: 30fb0100000000000000 |     irmovq $1, %r11   # len--;
0x06d: 61b2                 |     subq %r11, %rdx
                            | 
0x06f: 703400000000000000   |     jmp Loop                    
                            | 
0x078:                      | Done:
0x078: 90                   |     ret
                            | 
                            | 
                            | # Source链表和Dest链表的定义
0x080:                      |     .align 8
0x080:                      | src:
0x080: 0a00000000000000     |     .quad 0x00a
0x088: b000000000000000     |     .quad 0x0b0
0x090: 000c000000000000     |     .quad 0xc00
0x098:                      | dest:
0x098: 1101000000000000     |     .quad 0x111
0x0a0: 2202000000000000     |     .quad 0x222
0x0a8: 3303000000000000     |     .quad 0x333
                            | 
                            | 
0x200:                      |     .pos 0x200
0x200:                      | stack:

```

下面则是截图

![image-20251217184335747](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251217184341155.png)

## PartB

下面给出具体修改

```
bool instr_valid = icode in 
	{ INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,
	       IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ, IIADDQ };

bool need_regids =
	icode in { IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, 
		     IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ };

bool need_valC =
	icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL, IIADDQ };

word srcB = [
	icode in { IOPQ, IRMMOVQ, IMRMOVQ, IIADDQ  } : rB;
	icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;
	1 : RNONE;  # Don't need register
];


word dstE = [
	icode in { IRRMOVQ } && Cnd : rB;
	icode in { IIRMOVQ, IOPQ, IIADDQ } : rB;
	icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;
	1 : RNONE;  # Don't write any register
];

word aluA = [
	icode in { IRRMOVQ, IOPQ } : valA;
	icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ } : valC;
	icode in { ICALL, IPUSHQ } : -8;
	icode in { IRET, IPOPQ } : 8;
	# Other instructions don't need ALU
];

word aluB = [
	icode in { IRMMOVQ, IMRMOVQ, IOPQ, ICALL, 
		      IPUSHQ, IRET, IPOPQ, IIADDQ } : valB;
	icode in { IRRMOVQ, IIRMOVQ } : 0;
	# Other instructions don't need ALU
];
```

下面附上ISA测试截图

![image-20251217171540509](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251217171540595.png)

回归测试原有ISA截图

![image-20251217183236767](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251217183236818.png)

回归测试iaddq截图

![](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251217183333427.png)

## PartC

### 简述

讲真的，一下子看完archlab-cn.pdf的实验说明，没看懂，只知道有`ncopy.ys`，`pipe-full.hcl` ，`sdriver.yo和ldriver.yo`，`correctness.pl和benchmark.pl`，下面理一下思路。注意：下面的命令一切都是在sim/pipe/目录下执行。

1. `ncopy.ys`-汇编程序

   * 作用：这是我要实现的**Y86-64汇编程序**，其核心功能是：
     * 将一个数组`src`复制到另一个数组`dst`
     * 计算并返回`src`中大于零的元素个数，最终这个结果会存储在`%rax`寄存器中。
   * 目的：我需要优化它的**执行周期（CPE）**，确保它在不同输入规模下的执行效率和正确性。
2. `pipe-full.hcl`-流水线处理器的控制逻辑

   * 作用：这是**流水线CPU的硬件控制逻辑**，我需要在这里定义处理器如何执行`ncopy.ys`中的指令。它决定了：

     * **流水线各阶段**（取值、译码、执行、访存、写回）如何工作。
     * 如何优化流水线中的**数据转发、分支预测、冒险控制**等。
   * 和`ncopy.ys`的关系：

     * `ncopy.ys`运行时会依赖`pipe-full.hcl`里的控制逻辑，流水线的控制逻辑会影响`ncopy.ys`的执行效率。
3. `sdriver.yo`和`ldriver.yo`-测试程序
   * 作用：
     * `sdriver.yo`：测试`ncopy.ys`在一个小数组（4个元素）上的正确性。如果`ncopy.ys`正确执行，它会在`%rax`中返回2。
     * `ldriver.yo`：测试`ncopy.ys`在一个大数组（63个元素）上的正确性。如果`ncopy.ys`正确执行，那么它会在`%rax`中返回31。
4. `correctness.pl`-一个更严格的正确测试
   * 作用：这是一个**自动化测试工具**，用来确保`ncopy.ys`在各种不同大小的数组上的正确性。
   * 测试内容：
     * 它会自动生成多种不同大小的数组，并测试`ncopy.ys`函数是否正确复制数据并计算正整数个数。
5. `benchmark.pl`-性能测试工具
   * 作用：顾名思义，用来测试`ncopy.ys`的性能
   * 测试内容：
     * 它会运行`ncopy.ys`函数，计算并复制每一个元素需要多少周期（CPE）。
     * 目标是CPE<9。

下面我打算在修改之前，我先跑一遍，下面给出命令

1. `make drivers`：是用来生成测试驱动程序的，执行后会自动生成并汇编两个 `.yo` 文件（`sdriver.yo` 和 `ldriver.yo`），分别用于小数组和大数组的测试。

2. `make psim VERSION=full`：这个命令会重新编译**流水线模拟器（PSIM）**，编译时会由 `pipe-full.hcl` 生成对应的 `pipe-full.c`（HCL→C），再与 `psim.c`、`isa.c` 等一起编译生成可执行文件 `psim`。

   > 注意：`make VERSION=full`= `make drivers`+`make psim VERSION=full`

3. `./psim -g sdriver.yo`：`sdriver.yo`是一个测试小数组（4个元素）的程序，它会调用我们编写的`ncopy.ys`函数执行数组复制，并返回正整数的数量（即`%rax`中的值）。

   `sdriver.yo`/`ldriver.yo` 是驱动程序；用 `psim` 运行时体现流水线执行，用 `yis` 运行时体现顺序执行。

   > 我这里第一次运行时，出了一个问题，可能是没有执行`make clean`清理之前的编译缓存。因此我执行了`make clean`，然后执行`make VERSION=full`，再运行`./psim -g sdriver.yo`则成功出现了GUI页面，也运行成功。

4. `./psim -g ldriver.yo`：是用来 **测试大数组（63 个元素）** 的，它会启动 **PSIM 模拟器**（流水线） 并加载之前生成的 **`ldriver.yo`** 驱动程序文件，进入 **GUI 模式** 来运行模拟。

   下面附上截图

   ![image-20251217223243077](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251217223248193.png)

5. `../misc/yis sdriver.yo`：该指令会启动YIS模拟器（顺序执行），并加载`sdriver.yo`驱动程序。同样通过检查`%rax`的最终值是否正确。这回和之前的`./psim`不同，这个是使用YIS模拟器，`./psim -g sdriver.yo`是利用我们自己的pipe模拟器，YIS模拟器是来判断`ncopy.ys`汇编的正确性。

   下面附上截图

   ![](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251217224830106.png)

6. `correctness.pl`：是一个脚本，它会生成一系列的测试程序，每个程序的块从0到65,再加上一些更大的块长度（块长度就是我们需要复制的数组的长度，例如4个元素，63ge元素）。这个脚本提供了比`sdriver.yo`和`ldriver.yo`更严格的测试，同时**结果会随机变化**（每次测试，数组中的个数可能不同），这会验证程序的准确定和稳定性。

   具体操作步骤

   * 运行`correctness.pl`：它会生成多个测试程序，自动执行并验证 `ncopy.ys` 是否正确。

   * 如果在运行`correctness.pl`后发现某个特定长度的测试失败，可以用`gen-driver.pl`脚本来生成特定长度的**自定义驱动程序**。

   * 假设某个长度为 **K** 的测试失败，你可以通过以下命令生成自定义的驱动程序：

     ```
     ./gen-driver.pl -f ncopy.ys -n K -rc > driver.ys //生成自定义的驱动程序
     make driver.yo //将生成的driver.ys编译为.yo文件
     ../misc/yis driver.yo //使用YIS模拟器来运行这个编译后的驱动程序
     ```

   * 检查`%rax`寄存器的值：

     在测试过程中，YIS 模拟器会根据测试结果将值存储在 `%rax` 寄存器中。我们需要检查 `%rax` 的值来判断测试是否成功：

     **`0xaaaa`**：所有测试通过，程序没有错误。

     **`0xbbbb`**：计数不正确，说明 `ncopy.ys` 函数返回的正整数个数有误。

     **`0xcccc`**：`ncopy` 函数的长度超过了 1000 字节，可能是因为你的程序写得过长，需要优化。

     **`0xdddd`**：某些源数据没有被正确复制到目标数组。

     **`0xeeee`**：目标区域前后有数据被损坏（超出了目标数组的边界）。

   下面附上截图

   ![image-20251217230212925](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251217230213008.png)

7. `(cd ../y86-code; make testpsim)`： 这是基准测试，是利用sim/y86-code里面的Y86-64寄存程序进行测试，其实就是测试：我们改了`pipe-full.hcl`以后，有没有把CPU的其他行为搞坏。这个和第8点的回归测试目的一样（只不过回归测试更全面）。下面附上截图

   ![image-20251218091537278](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251218091537393.png)

8. `(cd ../ptest; make SIM=../pipe/psim TFLAGS=-i)`：这是进行回归测试：也是测试，我们的`pipe-full.hcl`逻辑是否正确。下面附上截图

   ![image-20251218092052612](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251218092052697.png)

   这里有错误很正常，因为`TFLAGS=-i`会另外测试我们在pipe-full.hcl里面添加的iaddq，但现在我只是在跑通，所以很正常，如果我们执行`(cd ../ptest; make SIM=../pipe/psim)`，那么将不会有问题。

9. `./correctness.pl -p`：这条指令和`./correctness`很像，但不同在于，`./correctness.pl`测的是 `ncopy.ys` 在**顺序执行**下是否正确，`correctness.pl -p` 测的是`ncopy` 在「流水线执行」下是否正确。下面附上截图

   ![](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251218092926758.png)

10. `benchmark.pl`：`benchmark.pl` 会用流水线 CPU（psim） 在大规模 ncopy 上测：平均每复制一个元素要多少个时钟周期（CPE）。下面附上截图

    ![](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251218093246840.png)

    正常，我还没修改自然是0分。

### 简述小结

因此我们知道了，目前看来，`ncopy.ys`是正确的，只是效率不高

1. 目的：

   * 修改`ncopy.ys`，目的是让其效率更高
   * 修改`pipe-full.hcl`，目的是加入`IIADDQ`同时效率更高。

2. 各个测试对比：

   * `sdriver.yo`和`ldrvier.yo`是来测试`ncopy.yo`的正确性
   * `correctness.pl`是使用YIS（顺序ISA模拟器）在多种不同规模下测试`ncopy.ys`，进行正确性测试。
   * `correctness.pl -p`：与`correctness.pl`不同在于，流水线执行正确性测试
   * `testpsim`：基准程序测试，使用 `sim/y86-code` 中提供的标准 Y86-64 程序；验证修改 `pipe-full.hcl` 后，处理器是否仍能正确执行“非 ncopy”程序；用于检测是否引入了影响全局行为的错误。
   * `ptest`：回归测试，对流水线处理器进行更全面、系统性的指令级回归测试；覆盖算术指令、跳转指令、调用与返回等多种场景；若未实现 `iaddq`，需避免使用 `TFLAGS=-i` 选项。
   * `benchmark.pl`：性能测试，在确认所有正确性测试通过后运行；使用流水线处理器 `psim` 测量 `ncopy.ys` 的执行性能；以 CPE（Cycles Per Element）作为评价指标，反映程序在流水线下的平均执行效率。

   > 注意：本实验中，同一个`ncopy.ys`程序，会在两种不同的处理器模型上被反复执行和验证：
   >
   > * `../misc/yis`：顺序处理器（YIS）
   > * `./psim`：流水线执行（PSIM）测试

### 阅读 `ncopy.ys` 和 `pipe-full.hcl`

#### **阅读ncopy.ys**

```
#/* $begin ncopy-ys */
##################################################################
# ncopy.ys - Copy a src block of len words to dst.
# Return the number of positive words (>0) contained in src.
#
# Include your name and ID here.
# Name:徐文博
# ID:1320240207
# Describe how and why you modified the baseline code.
#
##################################################################
# Do not modify this portion
# Function prologue.
# %rdi = src, %rsi = dst, %rdx = len
ncopy:

##################################################################
# You can modify this portion
	# Loop header
	xorq %rax,%rax		# count = 0;
	andq %rdx,%rdx		# len <= 0?
	jle Done		# if so, goto Done:

Loop:	mrmovq (%rdi), %r10	# read val from src...
	rmmovq %r10, (%rsi)	# ...and store it to dst
	andq %r10, %r10		# val <= 0?
	jle Npos		# if so, goto Npos:
	irmovq $1, %r10
	addq %r10, %rax		# count++
Npos:	irmovq $1, %r10
	subq %r10, %rdx		# len--
	irmovq $8, %r10
	addq %r10, %rdi		# src++
	addq %r10, %rsi		# dst++
	andq %rdx,%rdx		# len > 0?
	jg Loop			# if so, goto Loop:
##################################################################
# Do not modify the following section of code
# Function epilogue.
Done:
	ret
##################################################################
# Keep the following label at the end of your function
End:
#/* $end ncopy-ys */

```

* 入口约定：

  * 参数：`%rdi = src`，`%rsi = dst`，`%rdx = len`

  * 返回值放 `%rax`

* Loop header：初始化+处理len<=0

* Loop主体：每次处理1个元素

  * 从src读元素，然后复制到dst中
  * 判断正数，是正数，count(%rax)++
  * 更新len，src，dst。

* Loop循环条件：len > 0

* Done：返回。

#### **阅读pipe-full.hcl**

前面，那一大段都是在讲引用的库，以及声明好的指令（例如，INOP,IHALT等等），还有一些默认的指令和状态（冒泡呀之类的）。
需要注意以下几点

1. `wordsig F_predPC 'pc_curr->pc'	     # Predicted value of PC` ：`F_predPC`=预测的下一条指令PC

2. ```
   ##### Intermediate Values in Fetch Stage ###########################
   
   wordsig imem_icode  'imem_icode'      # icode field from instruction memory
   wordsig imem_ifun   'imem_ifun'       # ifun  field from instruction memory
   wordsig f_icode	'if_id_next->icode'  # (Possibly modified) instruction code
   wordsig f_ifun	'if_id_next->ifun'   # Fetched instruction function
   wordsig f_valC	'if_id_next->valc'   # Constant data of fetched instruction
   wordsig f_valP	'if_id_next->valp'   # Address of following instruction
   boolsig imem_error 'imem_error'	     # Error signal from instruction memory
   boolsig instr_valid 'instr_valid'    # Is fetched instruction valid?
   ```

   这块定义的是在取值阶段需要使用到的**组合逻辑信号**

   * `imem_icode`/`imem_ifun`是**刚刚从指令存储器读出来的原始指令**
   * `f_icode`/`f_ifun`是准备写进Decode阶段寄存器的指令，是这一拍（拍，指的是一个时间点）取值阶段得到的指令。
   * `f_valC`：这一拍 Fetch 阶段算出来的立即数，准备交给 Decode
   * `f_valP`：顺序执行时的下一条 PC（PC+指令长度），也是 **供 Decode / Execute 使用（如果是call指令，Execute的valA就是此时的valP，用来得到call跳转的地址）**。
   * `imem_error`：取值是否发生地址错误，**Fetch 阶段不会立刻停机**， 而是把错误转化为 `f_stat = SADR`，一路送进流水线。
   * `instr_valid`：这条指令的 icode 是否合法，会改变f_state。

3. ```
   ##### Pipeline Register D ##########################################
   wordsig D_icode 'if_id_curr->icode'   # Instruction code
   wordsig D_rA 'if_id_curr->ra'	     # rA field from instruction
   wordsig D_rB 'if_id_curr->rb'	     # rB field from instruction
   wordsig D_valP 'if_id_curr->valp'     # Incremented PC
   ```

   这些就像之前一样顾名思义，不过D_icode和d_icode是有区别的，D代表的是在Decode这一硬件里面存在的（用来保存这一拍Decode的状态），d代表的是要传给下个阶段的值（是一个组合逻辑信号，Decode就是传给Execute）。

   * `D_icode`：Decode 阶段正在处理的那条指令的 **指令类型**，来源于上一拍的`f_icode`。
   * `D_rA`：指令编码里的rA的字段。
   * `D_rB`：同`D_rA`。
   * `D_valP`：来源上一拍的`f_icode`，用途如下
     * `call`：把 `D_valP` 当返回地址压栈。
     * `jxx`：条件不成立时回到 `D_valP`。
     * `ret`：用于 PC 修正。

   注意：这里`f_ifun`会被IF/ID寄存器送到Eexcute（便于E阶段处理OPQ,JXX,RRMOVQ(条件)）。

4. ```
   ##### Intermediate Values in Decode Stage  #########################
   
   wordsig d_srcA	 'id_ex_next->srca'  # srcA from decoded instruction
   wordsig d_srcB	 'id_ex_next->srcb'  # srcB from decoded instruction
   wordsig d_rvalA 'd_regvala'	     # valA read from register file
   wordsig d_rvalB 'd_regvalb'	     # valB read from register file
   ```

   这里就不多做解释，就是注意D和d的区别，db表明这些物理上都不是存在的，是组合逻辑信号（Decode得到然后传送到Execute），用来传递到Execute，比如d_ravalA，就是Decode得到的，然后传到Execute，用来的到E_valA（假如它需要）。我们后面hcl要写的控制逻辑就是改写这些东西。

5. ```
   ##### Pipeline Register E ##########################################
   wordsig E_icode 'id_ex_curr->icode'   # Instruction code
   wordsig E_ifun  'id_ex_curr->ifun'    # Instruction function
   wordsig E_valC  'id_ex_curr->valc'    # Constant data
   wordsig E_srcA  'id_ex_curr->srca'    # Source A register ID
   wordsig E_valA  'id_ex_curr->vala'    # Source A value
   wordsig E_srcB  'id_ex_curr->srcb'    # Source B register ID
   wordsig E_valB  'id_ex_curr->valb'    # Source B value
   wordsig E_dstE 'id_ex_curr->deste'    # Destination E register ID
   wordsig E_dstM 'id_ex_curr->destm'    # Destination M register ID
   ```

   这里一句话概括了：Pipeline Register E（ID/EX）保存的是：Decode 阶段已经“决定好的一切”，供 Execute 阶段在下一拍直接使用。e_valE等等e开头的，就是通过这些E_valA和E_valB等等得到的。其他的Decode,Memory同理。

6. ```
   ##### Intermediate Values in Execute Stage #########################
   wordsig e_valE 'ex_mem_next->vale'	# valE generated by ALU
   boolsig e_Cnd 'ex_mem_next->takebranch' # Does condition hold?
   wordsig e_dstE 'ex_mem_next->deste'      # dstE (possibly modified to be RNONE)
   ```

   Execute 阶段“组合逻辑算出来的结果”，它们将在本拍末尾被写入 EX/MEM 流水线寄存器，供 Memory 阶段以及后续阶段使用。

7. ```
   ##### Pipeline Register M                  #########################
   wordsig M_stat 'ex_mem_curr->status'     # Instruction status
   wordsig M_icode 'ex_mem_curr->icode'	# Instruction code
   wordsig M_ifun  'ex_mem_curr->ifun'	# Instruction function
   wordsig M_valA  'ex_mem_curr->vala'      # Source A value
   wordsig M_dstE 'ex_mem_curr->deste'	# Destination E register ID
   wordsig M_valE  'ex_mem_curr->vale'      # ALU E value
   wordsig M_dstM 'ex_mem_curr->destm'	# Destination M register ID
   boolsig M_Cnd 'ex_mem_curr->takebranch'	# Condition flag
   boolsig dmem_error 'dmem_error'	        # Error signal from instruction memory
   
   ##### Intermediate Values in Memory Stage ##########################
   wordsig m_valM 'mem_wb_next->valm'	# valM generated by memory
   wordsig m_stat 'mem_wb_next->status'	# stat (possibly modified to be SADR)
   
   ##### Pipeline Register W ##########################################
   wordsig W_stat 'mem_wb_curr->status'     # Instruction status
   wordsig W_icode 'mem_wb_curr->icode'	# Instruction code
   wordsig W_dstE 'mem_wb_curr->deste'	# Destination E register ID
   wordsig W_valE  'mem_wb_curr->vale'      # ALU E value
   wordsig W_dstM 'mem_wb_curr->destm'	# Destination M register ID
   wordsig W_valM  'mem_wb_curr->valm'	# Memory M value
   ```

   这里只说明，比较特别的

   * `dmem_error` —— 内存访问是否出错

下面就是控制逻辑

#### **Fetch Stage**

```
################ Fetch Stage     ###################################

## What address should instruction be fetched at
word f_pc = [
	# Mispredicted branch.  Fetch at incremented PC
	M_icode == IJXX && !M_Cnd : M_valA;
	# Completion of RET instruction
	W_icode == IRET : W_valM;
	# Default: Use predicted value of PC
	1 : F_predPC;
];

## Determine icode of fetched instruction
word f_icode = [
	imem_error : INOP;
	1: imem_icode;
];

# Determine ifun
word f_ifun = [
	imem_error : FNONE;
	1: imem_ifun;
];

# Is instruction valid?
bool instr_valid = f_icode in 
	{ INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,
	  IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ };

# Determine status code for fetched instruction
word f_stat = [
	imem_error: SADR;
	!instr_valid : SINS;
	f_icode == IHALT : SHLT;
	1 : SAOK;
];

# Does fetched instruction require a regid byte?
bool need_regids =
	f_icode in { IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, 
		     IIRMOVQ, IRMMOVQ, IMRMOVQ };

# Does fetched instruction require a constant word?
bool need_valC =
	f_icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL };

# Predict next value of PC
word f_predPC = [
	f_icode in { IJXX, ICALL } : f_valC;
	1 : f_valP;
];
```

1. 选择PC来源

   * `M_icode == IJXX && !M_Cnd: M_valA`：之前取过的分支指令，现在发现“没跳”；那之前猜错了；用顺序PC（存在M_valA里）纠正。

   * `W_icode == IRET : W_valM`：`ret`的返回地址，只有到W阶段才知道；一旦知道，立刻用它。
   * `1: F_predPC`：没出事，继续用之前“猜的PC”。

2. 从内存中读取指令以及状态：`f_icode`，`f_ifun`，`f_state`，`instr_valid`。

3. 根据指令，判断是否需要寄存器，立即数：`need_regids`，`need_valC`。

4. 预测下一拍的指令：`f_predPC`。

#### **Decode Stage**

```
## What register should be used as the A source?
word d_srcA = [
	D_icode in { IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ  } : D_rA;
	D_icode in { IPOPQ, IRET } : RRSP;
	1 : RNONE; # Don't need register
];

## What register should be used as the B source?
word d_srcB = [
	D_icode in { IOPQ, IRMMOVQ, IMRMOVQ  } : D_rB;
	D_icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;
	1 : RNONE;  # Don't need register
];

## What register should be used as the E destination?
word d_dstE = [
	D_icode in { IRRMOVQ, IIRMOVQ, IOPQ} : D_rB;
	D_icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;
	1 : RNONE;  # Don't write any register
];

## What register should be used as the M destination?
word d_dstM = [
	D_icode in { IMRMOVQ, IPOPQ } : D_rA;
	1 : RNONE;  # Don't write any register
];

## What should be the A value?
## Forward into decode stage for valA
word d_valA = [
	D_icode in { ICALL, IJXX } : D_valP; # Use incremented PC
	d_srcA == e_dstE : e_valE;    # Forward valE from execute
	d_srcA == M_dstM : m_valM;    # Forward valM from memory
	d_srcA == M_dstE : M_valE;    # Forward valE from memory
	d_srcA == W_dstM : W_valM;    # Forward valM from write back
	d_srcA == W_dstE : W_valE;    # Forward valE from write back
	1 : d_rvalA;  # Use value read from register file
];

word d_valB = [
	d_srcB == e_dstE : e_valE;    # Forward valE from execute
	d_srcB == M_dstM : m_valM;    # Forward valM from memory
	d_srcB == M_dstE : M_valE;    # Forward valE from memory
	d_srcB == W_dstM : W_valM;    # Forward valM from write back
	d_srcB == W_dstE : W_valE;    # Forward valE from write back
	1 : d_rvalB;  # Use value read from register file
];

```

首先这里的 `D_...` 都来自 **IF/ID（D阶段流水线寄存器）**，也就是“当前 Decode 正在处理的那条指令”的字段：

- `D_icode`：指令类型
- `D_rA / D_rB`：指令编码里写的寄存器号（ra/rb 字段）
- `D_valP`：这条指令的顺序下一条 PC（PC+指令长度）

Decode 阶段会产出（写入 ID/EX，也就是 E 寄存器）：

- `d_srcA / d_srcB`：这条指令**需要读取**的源寄存器编号
- `d_dstE / d_dstM`：这条指令**将来要写回**的目的寄存器编号（E口 / M口）
- `d_valA / d_valB`：真正给 Execute 用的两个操作数值（**已经做过转发**）

还有两个是“从寄存器堆读出来的原始值”：

- `d_rvalA`：如果按 d_srcA 去寄存器文件读，读出来的值
- `d_rvalB`：如果按 d_srcB 去寄存器文件读，读出来的值

1. `d_srcA`：判断需要从哪个寄存器读取"A操作数"

2. `d_srcB`：判断需要从哪个寄存器读取“B操作数”

3. `d_dstE`：判断将来把ALU结果写到哪个寄存器

4. `d_dstM`：判断将来把“内存读出来的值”写到哪个寄存器

5. `d_valA`：A的值怎么拿

   * `ICALL,IJXX`：此时valA不是寄存器的值，而是valP（即顺序执行的下一条指令地址），`call`需要把返回地址压入栈，返回地址就是`D_valP`；`jXX`有时也需要valP（假设jXX条件判断错误），所以val=D_valP。

   * 数据转发（顺着优先级，从“最新”到“最旧”）

     如果`d_srcA`正好等于后面某条指令即将写的寄存器（触发数据转发）：

     * `== e_dstE`：说明执行阶段刚算出来（最新）->用`e_valE`。
     * `== M_dstM`：内存阶段刚读出来->用`m_valM`
     * `== M_dstE`：内存阶段有ALU结果->用`M_valE`
     * `== W_dstE`，`== W_dstM`：写回阶段最终值，分别用-> `W_valE`，`W_valM`。

   * `1:d_rvalA`：以上都不命中，那么就从寄存器中读取。

6. `d_valB`：同理，只是没有`call` / `jXX`的特例，因为`call` / `jXX`根本不使用B操作数。

#### **Execute Stage**

```
################ Execute Stage #####################################

## Select input A to ALU
word aluA = [
	E_icode in { IRRMOVQ, IOPQ } : E_valA;
	E_icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ } : E_valC;
	E_icode in { ICALL, IPUSHQ } : -8;
	E_icode in { IRET, IPOPQ } : 8;
	# Other instructions don't need ALU
];

## Select input B to ALU
word aluB = [
	E_icode in { IRMMOVQ, IMRMOVQ, IOPQ, ICALL, 
		     IPUSHQ, IRET, IPOPQ } : E_valB;
	E_icode in { IRRMOVQ, IIRMOVQ } : 0;
	# Other instructions don't need ALU
];

## Set the ALU function
word alufun = [
	E_icode == IOPQ : E_ifun;
	1 : ALUADD;
];

## Should the condition codes be updated?
bool set_cc = E_icode == IOPQ &&
	# State changes only during normal operation
	!m_stat in { SADR, SINS, SHLT } && !W_stat in { SADR, SINS, SHLT };

## Generate valA in execute stage
word e_valA = E_valA;    # Pass valA through stage

## Set dstE to RNONE in event of not-taken conditional move
word e_dstE = [
	E_icode == IRRMOVQ && !e_Cnd : RNONE;
	1 : E_dstE;
];
```

1. `aluA`：只是根据指令选择，哪一根线接到ALU的A端
   * `IRRMOVQ` / `IOPQ`：aluA使用寄存器里的值，`E_valA`（Decode已准备好的A值）。
   * `IIRMOVQ` / `IRMMOVQ` / `IMRMOVQ` ：这些指令都需要立即数valC，
   * `ICALL` / `PUSHQ`：都需要 `rsp = rsp - 8`，A端固定`-8`
   * `IRET` / `IPOPQ`：都要`rsp = rsp + 8`，A端固定`8`
2. `aluB`：B端通常是**“基址/被累加的值”** 。
3. `alufun`：ALU做什么运算，只有`IOPQ`（add/sub/and/xor）真正的运算是由`ifun`决定的，其余都是加法。
4. `set_cc`：这里很严格，只有IOPQ会更新条件码，出异常时不允许再更新条件码。
5. `e_valA`：这里将`E_valA`原样传下去，有下面两个用途
   * `rmmovq`：Memory阶段要把`valA`写入内存，这里valA是寄存器rA的值
   * `ret` / `pop`：Memory阶段要用`valA`作为访存的地址，从内存中取出传给PC/rA的值，这里valA是寄存器rsp的值。同时传给PC的话，就要修改之前预测的PC，返回去修改Fetch的`f_PC`。
   * `call`：Memory阶段要将valA压入栈（既内存中），这里的valA是Fetch阶段中的valP。
   * `JXX`：传下去，是为了后续Execute得出`e_Cnd`之后，如果决定不跳，那么需要修改预测的PC，返回去修改Fetch的`f_PC`。
6. `e_dstE`：`IRRMOVQ`包括了`rrmovq`（无条件）,`comvle`,`comvg`……（有条件），因此需要`e_Cnd`判断条件是否成立。其他时候都要传`E_dstE`，便于后续数据转发。

#### **Memory Stage**

```
################ Memory Stage ######################################

## Select memory address
word mem_addr = [
	M_icode in { IRMMOVQ, IPUSHQ, ICALL, IMRMOVQ } : M_valE;
	M_icode in { IPOPQ, IRET } : M_valA;
	# Other instructions don't need address
];

## Set read control signal
bool mem_read = M_icode in { IMRMOVQ, IPOPQ, IRET };

## Set write control signal
bool mem_write = M_icode in { IRMMOVQ, IPUSHQ, ICALL };

#/* $begin pipe-m_stat-hcl */
## Update the status
word m_stat = [
	dmem_error : SADR;
	1 : M_stat;
];
```

1. `mem_addr`：访内存用哪个地址
   * 使用`M_valE`的情况：这些指令的**内存地址**，都是在 **Execute 阶段算出来的**
   * 使用`M_valA`的情况：popq rA，ret这两条指令的访问地址是addr=rsp，而rsp的旧值是在**Execute阶段通过`E_valA`原样传下来的**。
2. `mem_read`：判断是否读内存
   * `IMRMOVQ`：从内存读数据
   * `IPOPQ`：从栈读数据
   * `IRET`：从栈读返回地址。
3. `mem_write`：判断是否写内存
   * `IRMMOVQ`：写数据到内存
   * `IPUSHQ`：写栈
   * `ICALL`：写返回地址
4. `m_state`：内存访问是否出错

#### **Write Stage**

```
#/* $end pipe-m_stat-hcl */

## Set E port register ID
word w_dstE = W_dstE;

## Set E port value
word w_valE = W_valE;

## Set M port register ID
word w_dstM = W_dstM;

## Set M port value
word w_valM = W_valM;

## Update processor status
word Stat = [
	W_stat == SBUB : SAOK;
	1 : W_stat;
];
```

这里就只是将W寄存器里的东西接到"寄存器文件写口"

写回阶段有两种写寄存器来源：

* `valE`：ALU计算的结果
* `valM`：从内存读的结果

State则是整个CPU的状态。

#### **Pipeline Register Control**

1. 先理解Stall（停住），Bubble（塞气泡）

   * Stall（停住）
     - 这个流水线寄存器 **本拍不更新**
     - 意味着：这一阶段的指令/数据 **继续保持上一拍的内容**
     - 用来“等一等”，别让错误继续传播
   * Bubble（塞气泡）
     - 这个流水线寄存器 **本拍强行写入一个 NOP（STAT_BUB）**
     - 意味着：把某条“错误/不该执行的指令”冲掉
     - 用来“清洗流水线”（flush）

2. F寄存器控制

   ```
   bool F_bubble = 0;
   bool F_stall =
   	# Conditions for a load/use hazard
   	E_icode in { IMRMOVQ, IPOPQ } &&
   	 E_dstM in { d_srcA, d_srcB } ||
   	# Stalling at fetch while ret passes through pipeline
   	IRET in { D_icode, E_icode, M_icode };
   
   ```

   * `F_bubble=0`：PC没办法变为NOP，所以F只会stall

   * `F_stall`有两类情况

     * load/use冒险

       条件：1.E阶段正在i执行`mrmovq`或`popq`（从内存读数据**写到寄存器**）;2.并且E阶段要写的寄存器`E_dstM`，正好是Decode阶段下一条指令要用的源寄存器`d_srcA/d_srcB`。

       例子

       ```
       mrmovq 0(%rdi), %r10   # 这条在E阶段，结果要到M阶段才出来
       addq   %r10, %rax      # 这条在D阶段，立刻要用 %r10
       ```

       这时候必须**要Fetch停住**。

       F stall 不是因为 Fetch 用不到值，而是因为：**“不能让错误的指令继续进入流水线”**。

     * ret冒险

       `IRET in {D_icode, E_icode, M_icode}`，因为ret的下一条指令要从栈里取出来，只有ret走到M/W（M结束，W开始得到valM）才知道PC。所以ret在流水线，必须停住**取值**，避免错误的指令进入流水线。

3. D寄存器控制

   ```
   bool D_stall = 
   	# Conditions for a load/use hazard
   	E_icode in { IMRMOVQ, IPOPQ } &&
   	 E_dstM in { d_srcA, d_srcB };
   
   bool D_bubble =
   	# Mispredicted branch
   	(E_icode == IJXX && !e_Cnd) ||
   	# Stalling at fetch while ret passes through pipeline
   	# but not condition for a load/use hazard
   	!(E_icode in { IMRMOVQ, IPOPQ } && E_dstM in { d_srcA, d_srcB }) &&
   	  IRET in { D_icode, E_icode, M_icode };
   ```

   * D_stall：只有在load/use时stall，原因和F一样，此时D阶段那条“用到load结果的指令”不能往前走。所以：**F stall + D stall** 一起发生。

   * D_bubble：两种情况会bubble（冲掉Decode里的错误指令）

     * A.分支预测失败——`E_icode == IJXX && !e_Cnd`

       E 阶段的 jxx 现在算出来条件不成立（`!e_Cnd`），说明之前 Fetch 按“跳转”预测取的指令是错的。

     * B.ret冒险（不是load/use）——`!(load/use) && IRET in { D_icode, E_icode, M_icode }`

       ret期间我们要停住Fetch，而Decode里面那条指令此时往往是**“取错的/不该继续的”** ，所以策略是F stall（不再取新），D则bubble（把Decode清空，等ret把正确PC给出来）。

4. E寄存器控制

   ```
   bool E_stall = 0;
   bool E_bubble =
       (E_icode == IJXX && !e_Cnd) ||
       E_icode in { IMRMOVQ, IPOPQ } &&
        E_dstM in { d_srcA, d_srcB };
   
   ```

   * E_stall永远是0，E阶段不会选择停住，而是用 bubble 来解决问题。
   * E_bubble两种情况
     * A.分支预测失败：当发现跳转失败，要清理掉D、E两级中的错误指令
     * B.load/use冒险：这是经典的策略：`F stall + D stall + E bubble`。这一拍结束后，E会被Bubble而计算出来的e_valE则会送到Memory，然后m_valM会被数据转发到Decode的d_valA/d_valB。

5. M寄存器

   ```
   bool M_stall = 0;
   # Start injecting bubbles as soon as exception passes through memory stage
   bool M_bubble = m_stat in { SADR, SINS, SHLT } || W_stat in { SADR, SINS, SHLT };
   
   ```

   * M_stall永远0：异常处理用bubble来做
   * M_bubble：只要Memory阶段或Writebakc阶段已经出现异常（地址错/非法指令/halt）就开始bubbleM。

6. W寄存器

   ```
   bool W_stall = W_stat in { SADR, SINS, SHLT };
   bool W_bubble = 0;
   ```

   * W_bubble永远0，W是最后一个阶段，不需要bubble
   * W_stall：异常时停住。

### 修改pipe-full.hcl

很好，我们阅读完了，也大致有了思路，我先往pipe-full.hcl里面加入`IADDQ`指令，然后修改`ncopu.ys`。

#### **加入`IADDQ`指令**

下面展示修改过得地方

1. instr_valid

   ```
   bool instr_valid = f_icode in 
   	{ INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,
   	  IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ, IIADDQ };
   ```

2. need_regids（iaddq有rB）

   ```
   bool need_regids =
   	f_icode in { IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, 
   		     IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ };
   ```

3. need_valC（iaddq有立即数）

   ```
   bool need_valC =
   	f_icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL, IIADDQ };
   ```

4. d_srcB

   ```
   word d_srcB = [
   	D_icode in { IOPQ, IRMMOVQ, IMRMOVQ, IIADDQ } : D_rB;
   	D_icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;
   	1 : RNONE;  # Don't need register
   ];
   ```

5. d_dstE

   ```
   word d_dstE = [
   	D_icode in { IRRMOVQ, IIRMOVQ, IOPQ, IIADDQ} : D_rB;
   	D_icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;
   	1 : RNONE;  # Don't write any register
   ];
   ```

6. aluA：把IIADDQ当成“立即数输入”

   ```
   word aluA = [
   	E_icode in { IRRMOVQ, IOPQ } : E_valA;
   	E_icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ } : E_valC;
   	E_icode in { ICALL, IPUSHQ } : -8;
   	E_icode in { IRET, IPOPQ } : 8;
   	# Other instructions don't need ALU
   ];
   ```

7. aluB：把IIADDQ作为“用valB”那类

   ```
   word aluB = [
   	E_icode in { IRMMOVQ, IMRMOVQ, IOPQ, ICALL, 
   		     IPUSHQ, IRET, IPOPQ, IIADDQ } : E_valB;
   	E_icode in { IRRMOVQ, IIRMOVQ } : 0;
   	# Other instructions don't need ALU
   ];
   ```

8. set_cc：通常iaddq也需要更新条件吗
   ```
   bool set_cc = E_icode in {IOPQ, IIADDQ} &&
   	# State changes only during normal operation
   	!m_stat in { SADR, SINS, SHLT } && !W_stat in { SADR, SINS, SHLT };
   ```

#### **测试**

下面进行测试

1. `make clean; make VERSION=full`

   附上截图

   ![image-20251219143108129](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251219143113247.png)

2. 回归测试：

   * `(cd ../y86-code; make testpsim)`

     下面附上截图

     ![image-20251219143510929](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251219143511033.png)

   * `(cd ../ptest; make SIM=../pipe/psim)`

     下面附上截图

     ![image-20251219143631271](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251219143631340.png)

3. 专门测试iaddq（现在没修改过），应该是不会出错

   `(cd ../ptest; make SIM=../pipe/psim TFLAGS=-i)`

   下面附上截图

   ![image-20251219143910699](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251219143910774.png)

以上，说明我们的修改和加入iaddq，是正确的，下面我要修改ncopy.ys，将其中可以用iaddq替换的替换掉。

### 修改ncopy.ys

#### **用`iaddq`替换**

`irmovq $1, %r10` + `addq %r10, %rax`  （count++）

`irmovq $1, %r10` + `subq %r10, %rdx`  （len--）

`irmovq $8, %r10` + `addq %r10, %rdi/%rsi`（指针++）

将以上的替换为

```
iaddq $1, %rax
iaddq $-1, %rdx
iaddq $8, %rdi
iaddq $8, %rsi
```

#### **4-way unroll（一次循环处理四个元素）**





































