# 实验四-优化Y86-64流水线处理器性能

## Y86-64指令集编码规范

首先是一些汇编的要求

* 参数的传法，第 1 个参数：`%rdi`，第 1 个参数：`%rsi`，第 3 个参数：`%rdx`，第4个参数：%rcx，第5个参数：%r8，第6个参数：%r9，返回值：`%rax`。
* 被调用者保存的寄存器：%rbx，%rbp，%r12，%r13，%r14，%r15。

**第一段：代码段（Code）**
 Y86 程序必须从 `.pos 0` 开始编写代码段，这是因为 Y86 CPU 启动时程序计数器 PC 固定为 0，第一条指令一定从内存地址 0 取指执行。`.pos 0` 并不是 CPU 指令，而是汇编器伪指令，用来告诉汇编器把接下来的机器码放在内存地址 0，从而保证 PC 能正确取到第一条指令。所有会被 CPU 执行的内容（主程序、函数代码）都属于代码段。

------

**第二段：数据段（Data）**
 数据段用于存放程序运行过程中需要访问的静态数据，例如链表节点等，通常通过 `.quad` 指令定义。`.quad` 表示在当前位置放置一个 64 位数据，而标签（如 `ele1:`）只是该地址的名字，本身不占内存。数据段应当放在代码段之后，并通过 `.align 8` 进行 8 字节对齐，以保证数据访问规范且不被 CPU 当作指令执行。

------

**第三段：栈段（Stack）**
 栈段是程序运行时使用的内存区域，用于保存函数返回地址和局部数据，由寄存器 `%rsp` 管理，且栈向低地址方向增长。通常通过 `.pos 0x200` 将栈起始地址放在较高的内存位置，再用标签 `stack:` 标记该地址。选择 0x200 是一种安全、保守的做法，它远离代码段和数据段，同时小于 Y86 地址空间上限（0xFFF），并满足 8 字节对齐要求。

------

**第四段：书写顺序与规则总结**
 在 Y86 实验中，推荐的书写顺序为：代码段 → 数据段 → 栈段。该顺序并非语法强制，而是为了保证程序入口明确、数据不被误执行、栈不覆盖代码和数据。`.pos 0` 必须保留作为程序入口，数据段只用于存放数据而不执行，栈段必须位于代码和数据之上并预留向下增长空间。而且最后的一行必须有回撤。

## Part A

### sum.ys-对链表元素进行迭代求和

这里就是简单地练习编写Y86代码，下面给出代码sum.ys

```

#------------------------------------------------
# sum.ys
# Name:徐文博
# 学号:1320240207
# 链表元素求和
#------------------------------------------------

    .pos 0
    irmovq stack, %rsp     # 初始化栈指针
    irmovq ele1, %rdi      # 传入第一个参数，链表头第一个元素地址
    call sum_list          # 调用sum_list函数
    halt                   # 程序结束

#------------------------------------------------
# long sum_list(list_ptr ls)
# %rdi = ls
# 返回指针在%rax中
#------------------------------------------------
sum_list:
    xorq %rax, %rax        #作为返回结果

Loop:
    andq %rdi, %rdi      # 判断参数ls是否为NULL
    je Done               # 如果是NULL，跳转到Done
    mrmovq 0(%rdi), %r10  # 取出当前节点的8字节值并放入r10
    addq %r10, %rax       # 将当前节点的值加到返回值中
    mrmovq 8(%rdi), %rdi  # 取出下一个节点的地址放入rdi中
    jmp Loop              # 继续循环
Done:
    ret


#------------------------------------------------
# 链表元素示例
#------------------------------------------------
    .align 8
ele1:
    .quad 0x00a     # long的大小为8字节（.quad），0x00a是当前节点的值
    .quad ele2       # 下一个节点的地址
ele2:
    .quad 0x0b0
    .quad ele3
ele3:
    .quad 0xc00
    .quad 0


#------------------------------------------------
# 栈空间
#------------------------------------------------
    .pos 0x200
stack:


```

下面给出sum.yo

```
                            | 
                            | #------------------------------------------------
                            | # sum.ys
                            | # Name:徐文博
                            | # 学号:1320240207
                            | # 链表元素求和
                            | #------------------------------------------------
                            | 
0x000:                      |     .pos 0
0x000: 30f40002000000000000 |     irmovq stack, %rsp     # 初始化栈指针
0x00a: 30f75000000000000000 |     irmovq ele1, %rdi      # 传入第一个参数，链表头第一个元素地址
0x014: 801e00000000000000   |     call sum_list          # 调用sum_list函数
0x01d: 00                   |     halt                   # 程序结束
                            | 
                            | #------------------------------------------------
                            | # long sum_list(list_ptr ls)
                            | # %rdi = ls
                            | # 返回指针在%rax中
                            | #------------------------------------------------
0x01e:                      | sum_list:
0x01e: 6300                 |     xorq %rax, %rax        #作为返回结果
                            | 
0x020:                      | Loop:
0x020: 6277                 |     andq %rdi, %rdi      # 判断参数ls是否为NULL
0x022: 734a00000000000000   |     je Done               # 如果是NULL，跳转到Done
0x02b: 50a70000000000000000 |     mrmovq 0(%rdi), %r10  # 取出当前节点的8字节值并放入r10
0x035: 60a0                 |     addq %r10, %rax       # 将当前节点的值加到返回值中
0x037: 50770800000000000000 |     mrmovq 8(%rdi), %rdi  # 取出下一个节点的地址放入rdi中
0x041: 702000000000000000   |     jmp Loop              # 继续循环
0x04a:                      | Done:
0x04a: 90                   |     ret
                            | 
                            | 
                            | #------------------------------------------------
                            | # 链表元素示例
                            | #------------------------------------------------
0x050:                      |     .align 8
0x050:                      | ele1:
0x050: 0a00000000000000     |     .quad 0x00a     # long的大小为8字节（.quad），0x00a是当前节点的值
0x058: 6000000000000000     |     .quad ele2       # 下一个节点的地址
0x060:                      | ele2:
0x060: b000000000000000     |     .quad 0x0b0
0x068: 7000000000000000     |     .quad ele3
0x070:                      | ele3:
0x070: 000c000000000000     |     .quad 0xc00
0x078: 0000000000000000     |     .quad 0
                            | 
                            | 
                            | #------------------------------------------------
                            | # 栈空间
                            | #------------------------------------------------
0x200:                      |     .pos 0x200
0x200:                      | stack:
                            | 

```

下面附上运行截图

![image-20251217184458419](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251217184458465.png)

### rsum.ys-对链表元素进行递归求和

这里比上一道需要注意的是，我们在递归时，第一个参数一定是存放在%rdi的，所以在递归之前`long val = ls->val;`，只能用%r10存放节点数值，然后再压入栈中（因为这是调用者保存，后面我们递归调用rsum_list会覆盖寄存器%r10），而这里也需要两个ret，一个是在Empty链表时ret，一个是正常递归完ret避免顺序执行到Empty:。

下面附上rsum.ys代码

```
# rsum.ys
# Name:徐文博
# 学号:1320240207


    .pos 0
    irmovq stack, %rsp    # 初始化栈指针
    irmovq ele1, %rdi     # 传入第一个参数，链表头第一个元素地址
    call rsum_list        # 调用rsum_list函数
    halt                  # 程序结束

#------------------------------------------------
# long rsum_list(list_ptr ls)
# %rdi = ls
# 返回指保存在%rax中
#------------------------------------------------
rsum_list:
    # if (!ls) return 0;
    andq %rdi,%rdi      # 判断参数ls是否为NULL
    je Empty             # 如果是NULL，跳转到Done，即空链表
    
    # long val = ls->value;
    mrmovq 0(%rdi), %r10  # 取出当前节点的8字节值并放入r10
                        #这里不用%rdi,是因为下面还要用到%rdi取下一个节点地址
                        #并call时要用到%rdi传参
    pushq %r10         # 将当前节点的值压栈保存,调用者保存
                       # 以便下面递归调用后再取出使用

    # long rest = rsum_list(ls->next);
    mrmovq 8(%rdi),%rdi # 取出下一个节点的地址放入rdi中
    call rsum_list      # 递归调用rsum_list

    # return val + rest;
    popq %r10
    addq %r10,%rax
    ret

    
Empty:
    xorq %rax,%rax        # 作为返回结果初始化为0
    ret


# 链表元素示例
    .align 8
ele1:
    .quad 0x00a     # long的大小为8字节（.quad），0x00a是当前节点的值
    .quad ele2       # 下一个节点的地址
ele2:
    .quad 0x0b0
    .quad ele3
ele3:
    .quad 0xc00
    .quad 0


# 栈区
    .pos 0x200
stack:


```

下面附上rsum.yo内容

```
                            | # rsum.ys
                            | # Name:徐文博
                            | # 学号:1320240207
                            | 
                            | 
0x000:                      |     .pos 0
0x000: 30f40002000000000000 |     irmovq stack, %rsp    # 初始化栈指针
0x00a: 30f75000000000000000 |     irmovq ele1, %rdi     # 传入第一个参数，链表头第一个元素地址
0x014: 801e00000000000000   |     call rsum_list        # 调用rsum_list函数
0x01d: 00                   |     halt                  # 程序结束
                            | 
                            | #------------------------------------------------
                            | # long rsum_list(list_ptr ls)
                            | # %rdi = ls
                            | # 返回指保存在%rax中
                            | #------------------------------------------------
0x01e:                      | rsum_list:
                            |     # if (!ls) return 0;
0x01e: 6277                 |     andq %rdi,%rdi      # 判断参数ls是否为NULL
0x020: 734d00000000000000   |     je Empty             # 如果是NULL，跳转到Done，即空链表
                            |     
                            |     # long val = ls->value;
0x029: 50a70000000000000000 |     mrmovq 0(%rdi), %r10  # 取出当前节点的8字节值并放入r10
                            |                         #这里不用%rdi,是因为下面还要用到%rdi取下一个节点地址
                            |                         #并call时要用到%rdi传参
0x033: a0af                 |     pushq %r10         # 将当前节点的值压栈保存,调用者保存
                            |                        # 以便下面递归调用后再取出使用
                            | 
                            |     # long rest = rsum_list(ls->next);
0x035: 50770800000000000000 |     mrmovq 8(%rdi),%rdi # 取出下一个节点的地址放入rdi中
0x03f: 801e00000000000000   |     call rsum_list      # 递归调用rsum_list
                            | 
                            |     # return val + rest;
0x048: b0af                 |     popq %r10
0x04a: 60a0                 |     addq %r10,%rax
0x04c: 90                   |     ret
                            | 
                            |     
0x04d:                      | Empty:
0x04d: 6300                 |     xorq %rax,%rax        # 作为返回结果初始化为0
0x04f: 90                   |     ret
                            | 
                            | 
                            | # 链表元素示例
0x050:                      |     .align 8
0x050:                      | ele1:
0x050: 0a00000000000000     |     .quad 0x00a     # long的大小为8字节（.quad），0x00a是当前节点的值
0x058: 6000000000000000     |     .quad ele2       # 下一个节点的地址
0x060:                      | ele2:
0x060: b000000000000000     |     .quad 0x0b0
0x068: 7000000000000000     |     .quad ele3
0x070:                      | ele3:
0x070: 000c000000000000     |     .quad 0xc00
0x078: 0000000000000000     |     .quad 0
                            | 
                            | 
                            | # 栈区
0x200:                      |     .pos 0x200
0x200:                      | stack:
                            | 

```



下面附上运行截图

![image-20251217184425160](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251217184425267.png)

### copy.ys-复制元素

下面附上代码以及运行效果

```
# copy.ys
# Name:徐文博
# 学号:1320240207
# 链表元素复制


    .pos 0
    irmovq stack, %rsp     # 初始化栈指针
    irmovq src, %rdi   # 传入第一个参数，Source链表头第一个元素地址
    irmovq dest, %rsi  # 传入第二个参数，Dest链表头第一个元素地址
    irmovq $3, %rdx     # 传入第三个参数，链表元素个数
    call copy_list        # 调用copy_list函数
    halt                  # 程序结束

#------------------------------------------------
# void copy_list(list_ptr src, list_ptr dest, long n)
# %rdi = src
# %rsi = dest
# %rdx = n
#------------------------------------------------
copy_list:
    xorq %rax, %rax     # long result = 0;

Loop:
    andq %rdx, %rdx     # len <= 0?
    je Done            # if (len <= 0) break;

    mrmovq (%rdi), %r10 # long val = *src;
    rmmovq %r10, (%rsi) # *dest = val;
    xorq %r10, %rax     # result ^= val;

    irmovq $8, %r11 #因为long类型占8字节，
                    #因此src++和dest++都要加8
                    #Y86只支持寄存器相加
    addq %r11, %rdi   # src++;
    addq %r11, %rsi   # dest++;

    irmovq $1, %r11   # len--;
    subq %r11, %rdx

    jmp Loop                    

Done:
    ret


# Source链表和Dest链表的定义
    .align 8
src:
    .quad 0x00a
    .quad 0x0b0
    .quad 0xc00
dest:
    .quad 0x111
    .quad 0x222
    .quad 0x333


    .pos 0x200
stack:

```

下面是copy.yo

```
                            | # copy.ys
                            | # Name:徐文博
                            | # 学号:1320240207
                            | # 链表元素复制
                            | 
                            | 
0x000:                      |     .pos 0
0x000: 30f40002000000000000 |     irmovq stack, %rsp     # 初始化栈指针
0x00a: 30f78000000000000000 |     irmovq src, %rdi   # 传入第一个参数，Source链表头第一个元素地址
0x014: 30f69800000000000000 |     irmovq dest, %rsi  # 传入第二个参数，Dest链表头第一个元素地址
0x01e: 30f20300000000000000 |     irmovq $3, %rdx     # 传入第三个参数，链表元素个数
0x028: 803200000000000000   |     call copy_list        # 调用copy_list函数
0x031: 00                   |     halt                  # 程序结束
                            | 
                            | #------------------------------------------------
                            | # void copy_list(list_ptr src, list_ptr dest, long n)
                            | # %rdi = src
                            | # %rsi = dest
                            | # %rdx = n
                            | #------------------------------------------------
0x032:                      | copy_list:
0x032: 6300                 |     xorq %rax, %rax     # long result = 0;
                            | 
0x034:                      | Loop:
0x034: 6222                 |     andq %rdx, %rdx     # len <= 0?
0x036: 737800000000000000   |     je Done            # if (len <= 0) break;
                            | 
0x03f: 50a70000000000000000 |     mrmovq (%rdi), %r10 # long val = *src;
0x049: 40a60000000000000000 |     rmmovq %r10, (%rsi) # *dest = val;
0x053: 63a0                 |     xorq %r10, %rax     # result ^= val;
                            | 
0x055: 30fb0800000000000000 |     irmovq $8, %r11 #因为long类型占8字节，
                            |                     #因此src++和dest++都要加8
                            |                     #Y86只支持寄存器相加
0x05f: 60b7                 |     addq %r11, %rdi   # src++;
0x061: 60b6                 |     addq %r11, %rsi   # dest++;
                            | 
0x063: 30fb0100000000000000 |     irmovq $1, %r11   # len--;
0x06d: 61b2                 |     subq %r11, %rdx
                            | 
0x06f: 703400000000000000   |     jmp Loop                    
                            | 
0x078:                      | Done:
0x078: 90                   |     ret
                            | 
                            | 
                            | # Source链表和Dest链表的定义
0x080:                      |     .align 8
0x080:                      | src:
0x080: 0a00000000000000     |     .quad 0x00a
0x088: b000000000000000     |     .quad 0x0b0
0x090: 000c000000000000     |     .quad 0xc00
0x098:                      | dest:
0x098: 1101000000000000     |     .quad 0x111
0x0a0: 2202000000000000     |     .quad 0x222
0x0a8: 3303000000000000     |     .quad 0x333
                            | 
                            | 
0x200:                      |     .pos 0x200
0x200:                      | stack:

```

下面则是截图

![image-20251217184335747](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251217184341155.png)

## PartB

下面给出具体修改

```
bool instr_valid = icode in 
	{ INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,
	       IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ, IIADDQ };

bool need_regids =
	icode in { IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, 
		     IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ };

bool need_valC =
	icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL, IIADDQ };

word srcB = [
	icode in { IOPQ, IRMMOVQ, IMRMOVQ, IIADDQ  } : rB;
	icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;
	1 : RNONE;  # Don't need register
];


word dstE = [
	icode in { IRRMOVQ } && Cnd : rB;
	icode in { IIRMOVQ, IOPQ, IIADDQ } : rB;
	icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;
	1 : RNONE;  # Don't write any register
];

word aluA = [
	icode in { IRRMOVQ, IOPQ } : valA;
	icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ } : valC;
	icode in { ICALL, IPUSHQ } : -8;
	icode in { IRET, IPOPQ } : 8;
	# Other instructions don't need ALU
];

word aluB = [
	icode in { IRMMOVQ, IMRMOVQ, IOPQ, ICALL, 
		      IPUSHQ, IRET, IPOPQ, IIADDQ } : valB;
	icode in { IRRMOVQ, IIRMOVQ } : 0;
	# Other instructions don't need ALU
];
```

下面附上ISA测试截图

![image-20251217171540509](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251217171540595.png)

回归测试原有ISA截图

![image-20251217183236767](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251217183236818.png)

回归测试iaddq截图

![](https://raw.githubusercontent.com/Wooden-Flute/image2/main/img/20251217183333427.png)

## PartC